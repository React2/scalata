# scalata
Massive data generator for load tests.

Scalata is a streamming data generator that has the following data __PIPELINE__:

TRANSLATE -> GENERATE -> PARSE -> EXPORT

The pipeline is created with scalaz-streams, and the generated data is streammed to the output.

```scala
// Data Generation Pipeline
def pipeline: Task[Unit] = root |> generator |>> parser |>> exporter

// at the end of the universe...
pipeline.run
```

## Benchmark

* Parser = MongoParser
* Exporter = ConsoleExporter

1M objects ~ 2 minutes [TODO: Improve]

## Configuration

The _template.json_ file is where you must configure the program.

__There are three keys to configure__:

* parser = The parser plugin that transforms the raw data to whatever you want.
* exporter = The exporter plugin will be responsable to export the parsed data to anywhere.
* data_structure = your data definition, class, arrays and fields.

```json
{
    "parser": "MongoParser",
    "exporter": {
        "name": "FileExporter",
        "output": "club-data.js"
    },
    "data_structure": {
        "repeat": 100,
        "fields": [
            {
                "type": "{{int-64}}",
                "name": "timestamp"
            },
            {
                "type": "{{date}}",
                "name": "birthday"
            },
            {
                "type": "{{object}}",
                "name": "club",
                "fields": [
                    {
                        "type": "{{string}}",
                        "name": "name"
                    },
                    {
                        "type": "{{int-32}}",
                        "name": "age"
                    }
                ]
            }
        ]
    }
}

```

### Generators ###

Generators are responsable of generating random data. 

```scala
trait Generator[+U] {
  self =>

  def one: U

  def map[S](f: U => S): Generator[S] = new Generator[S] {
    def one = f(self.one)
  }

  def flatMap[S](f: U => Generator[S]): Generator[S] = new Generator[S] {
    def one = f(self.one).one
  }
}
```

__Very basic generators__

```scala
val integers = new Generator[Int] {
  val rand = new java.util.Random
  def one = rand.nextInt()
}

val booleans: Generator[Boolean] = for (x <- integers) yield x > 0

```

__A more complex generator__

```scala

class RandomDateGen(lo: Int, hi: Int) extends DateGen {
  import java.util.{Calendar, GregorianCalendar}

  private val gc = new GregorianCalendar()
  private val yearGen = Gen.choose(lo, hi)
  private val dayGen = Gen.choose(1, gc.getActualMaximum(Calendar.DAY_OF_YEAR))

  private lazy val dateGen: Generator[DateField] = for {
    year <- yearGen
    day <- dayGen
  } yield {
    gc.set(Calendar.YEAR, year)
    gc.set(Calendar.DAY_OF_YEAR, day)
    gc.getTime
  }

  override def one = dateGen.one

}
```

### Parsers and Exporters ###

The data generated by the generators are piped to a Parser. The parser will transform the raw data into whatever format you want to export, such XML, JSON, TXT, or even MongoDB datatypes.
After that, the parsed data will be piped to an exporter, wich can be a ConsoleExporter, a FileExporter, or custom exporters.

Parsers and Exporters are plugin like. You can write your own plugin and pass it's classpath while running the program.
ex:

```
--parser=your.project.path.XmlParser --exporter=your.project.path.OracleExporter
```

```scala
trait Parser[-A, +B] {
  def parse(a: A): B
}
```

```scala
trait Exporter {
  def export(f: Any): Unit
}
```

# Run
```
./scalata.sh --definition=data/template.json --parser=your.project.path.XmlParser
```
